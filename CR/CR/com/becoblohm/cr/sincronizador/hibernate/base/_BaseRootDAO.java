/*
 * $$Id: _BaseRootDAO.java,v 1.2 2005/03/10 15:51:14 programa8 Exp $$
 * ===========================================================================
 * Material Propiedad SuperFerretería EPA C.A. 
 *
 * Creado por	: Superferretería EPA / Hibernate Synchronizer
 * Creado en 	: Wed Mar 02 14:08:23 GMT-04:00 2005
 * (C) Copyright SuperFerretería EPA C.A. Todos los Derechos Reservados
 * 
 * ---------------------------------------------------------------------------
 * Actualizaciones:
 * ---------------------------------------------------------------------------
 * $$Log: _BaseRootDAO.java,v $
 * $Revision 1.2  2005/03/10 15:51:14  programa8
 * $CR al 10/03/2005. Merging desde branch STABLE
 * $
 * $Revision 1.1.4.4  2005/03/07 12:54:49  programa8
 * $Integración Versiones Estable e Inestable al 07/03/2005
 * $
 * $Revision 1.1.6.3  2005/03/02 18:59:27  programa8
 * $Cambio en tabla Auditoria - idauditoria promovido a BIGINT
 * $
 * $Revision 1.1.4.3  2005/03/02 18:23:13  programa8
 * $Cambio en tabla Auditoria - idauditoria promovido a BIGINT
 * $
 * $Revision 1.1.4.2.1  2005/02/28 18:13:49  programa8
 * $Version Inestable al 28/02/2005
 * $    *-Preparación para trabajar sin administrador de ventanas.
 * $    *-Reordenamiento de GUI
 * $    *-Mejoras en scroll y pantallas de pagos
 * $    *- Mantenimiento de estado en Cliente en Espera
 * $    *- Avisos del sistema manejados por la aplicacion
 * $    *- Desbloqueo de caja por otros usuarios reparado.
 * $
 * $Revision 1.1.4.2  2005/02/15 17:43:39  acastillo
 * $Ajuste de estructura prodcodigoexterno
 * $$
 * ===========================================================================
 */

package com.becoblohm.cr.sincronizador.hibernate.base;

import java.io.File;
import java.io.Serializable;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import net.sf.hibernate.Criteria;
import net.sf.hibernate.HibernateException;
import net.sf.hibernate.Query;
import net.sf.hibernate.ReplicationMode;
import net.sf.hibernate.Session;
import net.sf.hibernate.SessionFactory;
import net.sf.hibernate.Transaction;
import net.sf.hibernate.cfg.Configuration;
import net.sf.hibernate.expression.Expression;
import net.sf.hibernate.expression.Order;
import net.sf.hibernate.type.Type;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;


/**
 * This class has been automatically generated by Hibernate Synchronizer.
 * For more information or documentation, visit The Hibernate Synchronizer page
 * at http://www.binamics.com/hibernatesync or contact Joe Hudson at joe@binamics.com.
 */
@SuppressWarnings("rawtypes")
public abstract class _BaseRootDAO {
	/** Log para este objeto. */
	private static Log log = LogFactory.getLog(_BaseRootDAO.class);

	/**
	 * Save Transaction.
	 * 
	 * @see Session#save(java.lang.Object)
	 */
	public static final int OPERACION_SAVE = 0;

	/**
	 * Update Transaction.
	 * 
	 * @see Session#update(java.lang.Object)
	 */
	public static final int OPERACION_UPDATE = 1;

	/**
	 * SaveOrUpdate Transaction.
	 * 
	 * @see Session#saveOrUpdate(java.lang.Object)
	 */
	public static final int OPERACION_SAVE_UPDATE = 2;

	/**
	 * SavaOrUpdateCopy Transaction.
	 * 
	 * @see Session#saveOrUpdateCopy(java.lang.Object)
	 */
	public static final int OPERACION_SAVE_UPDATE_COPY = 3;

	/**
	 * Replicate Transaction.
	 * 
	 * @see Session#replicate(java.lang.Object,
	 *      net.sf.hibernate.ReplicationMode)
	 */
	public static final int OPERACION_REPLICAR = 4;

	/**
	 * Load Transaction.
	 * 
	 * @see Session#load(java.lang.Class, java.io.Serializable)
	 */
	public static final int OPERACION_CARGAR = 5;

	/**
	 * Get Transaction.
	 * 
	 * @see Session#get(java.lang.Class, java.io.Serializable)
	 */
	public static final int OPERACION_OBTENER = 6;

	/**
	 * Refresh transaction.
	 * 
	 * @see Session#refresh(java.lang.Object)
	 */
	public static final int OPERACION_REFRESH = 7;

	/**
	 * Delete transaction
	 * @see Session#delete(java.lang.Object)
	 */
	public static final int OPERACION_DELETE = 8;

	/** Map to store the sessionFactories */
	protected static Map<String,Object> sessionFactoryMap = new HashMap<String,Object>();
	/** ThreadLocal object to store sessions */
	protected static ThreadLocal<Stack<Object[]>> threadedSessions = new ThreadLocal<Stack<Object[]>>();

	/**
	 * Configure the session factory by reading hibernate config file
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public static void initialize () throws HibernateException {
		initialize((String) null);
	}
	
	/**
	 * Configure the session factory by reading hibernate config file
	 * @param configFileName the name of the configuration file
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public static void initialize (String configFileName) throws HibernateException  {
		if (null == configFileName && sessionFactoryMap.size() > 0) return;
		else if (null != sessionFactoryMap.get(configFileName)) return;
		else {
			Configuration cfg = new Configuration();
			if (null == configFileName)
				cfg.configure();
			else
				cfg.configure(configFileName);
			setSessionFactory(configFileName, cfg.buildSessionFactory());
		}
	}

	/**
	 * Configure the session factory by reading hibernate config file
	 * @param configFile the configuration file
	 * @throws HibernateException
	 * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se comentó código muerto
	* Fecha: agosto 2011
	*/
	public static void initialize(File configFile) throws HibernateException {
		if (null == configFile && sessionFactoryMap.size() > 0)
			return;
		else if (null != sessionFactoryMap.get(configFile.getName()))
			return;
		else {
			Configuration cfg = new Configuration();
			/*if (null == configFile)
				cfg.configure();
			else*/
				cfg.configure(configFile);
			setSessionFactory(configFile.getName(), cfg.buildSessionFactory());
		}
	}
	
	/**
	 * Set the session factory
	 * @param sessionFactory The SessionFactory
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected static void setSessionFactory (SessionFactory sessionFactory) {
		setSessionFactory((String) null, sessionFactory);
	}

	/**
	 * Set the session factory
	 * @param configFileName The config File Name
	 * @param sessionFactory The SessionFactory
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected static void setSessionFactory (String configFileName, SessionFactory sessionFactory) {
		sessionFactoryMap.put(configFileName, sessionFactory);
	}

	/**
	 * Return the SessionFactory that is to be used by these DAOs.  Change this
	 * and implement your own strategy if you, for example, want to pull the SessionFactory
	 * from the JNDI tree.
	 * @return SessionFactory an session Factory
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected SessionFactory getSessionFactory() {
		return getSessionFactory (getConfigurationFileName());
	}

	/**
	 * @param configFile The config File Name
	 * @return SessionFactory an session Factory
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public static SessionFactory getSessionFactory(String configFile) {
        if (sessionFactoryMap.size() == 1) {
            return (SessionFactory) sessionFactoryMap.values().toArray()[0];
        }
        SessionFactory sessionFactory = (SessionFactory) sessionFactoryMap
                .get(configFile);
        if (null == sessionFactory) {
            if (null == configFile) {
                throw new RuntimeException(
                        "The session factory has not been initialized.");
            }
            throw new RuntimeException("The session factory for '" + configFile
                    + "' has not been initialized.");
        }
        return sessionFactory;
	}

	/**
	 * Return the name of the configuration file on this DAO
	 * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 * @return Set or null, depends of Config File Name map
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Set'
	* Fecha: agosto 2011
	*/
	public static Set<Map.Entry<String,Object>> getConfigurationFileNames() {
		if (sessionFactoryMap != null) {
			return sessionFactoryMap.entrySet();
		}
		return null;
	}
	
	/**
	 * Return a new Session object that must be closed when the work has been completed.
	 * @return the active Session
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Session getSession() throws HibernateException {
		return createSession();
	}

	/**
	 * Return a new Session object that must be closed when the work has been completed.
	 * @return the active Session
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public static Session createSession() throws HibernateException {
		return createSession(null);
	}

	/**
	 * Return a new Session object that must be closed when the work has been completed.
	 * @param configFile the config file must match the meta attribute "config-file" in the hibernate mapping file
	 * @return the active Session
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Stack'
	* Fecha: agosto 2011
	*/
	public static Session createSession(String configFile) throws HibernateException {
		Stack<Object[]> sessionStack = threadedSessions.get();
		Session session = null;
		if (null == sessionStack) {
			sessionStack = new Stack<Object[]>();
			threadedSessions.set(sessionStack);
		}
		if (sessionStack.size() > 0) {
			Object[] arr = sessionStack.peek();
			String cf = (String) arr[0];
			if (null == cf) {
				session = (Session) arr[1];
			}
			else if (null != cf && null != configFile) {
				if (cf.equals(configFile)) session = (Session) arr[1];
			}
			if (null == session) {
				session = getSessionFactory(configFile).openSession();
				arr = new Object[2];
				arr[0] = configFile;
				arr[1] = session;
				sessionStack.push(arr);
			}
		}
		else {
			session = getSessionFactory(configFile).openSession();
			Object[] arr = new Object[2];
			arr = new Object[2];
			arr[0] = configFile;
			arr[1] = session;
			sessionStack.push(arr);
		}
		return session;
	}
	
	/**
	 * Return the name of the configuration file to be used with this DAO or null if default
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 * @return String or null, depends of the default Config File Name
	 */
	public String getConfigurationFileName () {
		return null;
	}

	/**
	 * Return the specific Object class that will be used for class-specific
	 * implementation of this DAO.
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 * @return the reference Class
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Class'
	* Fecha: agosto 2011
	*/
	protected abstract Class<?> getReferenceClass();

	/**
	 * Close the session
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Stack'
	* Fecha: agosto 2011
	*/
	public void closeSession () throws HibernateException {
		Stack<Object[]> sessionStack =  threadedSessions.get();
		if (null != sessionStack) {
			Object[] arr = sessionStack.peek();
			String cf = (String) arr[0];
			if (null == cf) {
				Session session = (Session) arr[1];
				session.close();
				sessionStack.pop();
			}
			else {
				String configurationFile = getConfigurationFileName();
				if (null != configurationFile && configurationFile.equals(cf)) {
					Session session = (Session) arr[1];
					session.close();
					sessionStack.pop();
				}
			}
		}
	}

	/**
	 * Begin the transaction related to the session
	 * @param s The session to use to get transaction
	 * @return Transaction The session to use to get transaction
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public Transaction beginTransaction(Session s) throws HibernateException {
		return s.beginTransaction();
	}

	/**
	 * Commit the given transaction
	 * @param t The Transaction to commit
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public void commitTransaction(Transaction t) throws HibernateException {
		t.commit();
	}

	/**
	 * Execute a query. 
	 * @param query a query expressed in Hibernate's query language
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	
	public List find(String query) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return find(query, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Perform a find but use the session given instead of creating a new one.
	 * @param query a query expressed in Hibernate's query language
	 * @param s the Session to use
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List find(String query, Session s) throws HibernateException {
		return s.find(query);
	}

	/**
	 * Return all objects related to the implementation of this DAO with no filter.
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List findAll () throws HibernateException {
		Session s = null;
		try {
			s = getSession();
    		return findAll(s);
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Return all objects related to the implementation of this DAO with no filter.
	 * Use the session given.
	 * @param s the Session
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List findAll (Session s) throws HibernateException {
   		return findAll(s, getDefaultOrderProperty());
	}

	/**
	 * Return all objects related to the implementation of this DAO with no filter.
	 * @param orderProperty the property to order
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List findAll (String orderProperty) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return findAll(s, orderProperty);
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Return all objects related to the implementation of this DAO with no filter.
	 * Use the session given.
	 * @param s the Session
	 * @param orderProperty the property to order
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List findAll (Session s, String orderProperty) throws HibernateException {
		Criteria crit = createCriteria(s);
		if (null != orderProperty) crit.addOrder(Order.asc(orderProperty));
		return crit.list();
	}

	/**
	 * Return all objects related to the implementation of this DAO with a filter.
	 * Use the session given.
	 * @param propName the name of the property to use for filtering
	 * @param filter the value of the filter
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected java.util.List findFiltered (String propName, Object filter) throws HibernateException {
		return findFiltered(propName, filter, getDefaultOrderProperty());
	}

	/**
	 * Return all objects related to the implementation of this DAO with a filter.
	 * Use the session given.
	 * @param propName the name of the property to use for filtering
	 * @param filter the value of the filter
	 * @param orderProperty the name of the property used for ordering
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected java.util.List findFiltered (String propName, Object filter, String orderProperty) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return findFiltered(s, propName, filter, orderProperty);
		}
		finally {
			closeSession();
		}
	}
	
	/**
	 * Return all objects related to the implementation of this DAO with a filter.
	 * Use the session given.
	 * @param s the Session
	 * @param propName the name of the property to use for filtering
	 * @param filter the value of the filter
	 * @param orderProperty the name of the property used for ordering
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected java.util.List findFiltered (Session s, String propName, Object filter, String orderProperty) throws HibernateException {
		Criteria crit = createCriteria(s);
		crit.add(Expression.eq(propName, filter));
		if (null != orderProperty) crit.addOrder(Order.asc(orderProperty));
		return crit.list();
	}
	
	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * @param name the name of a query defined externally 
	 * @return Query
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the session given.
	 * @param name the name of a query defined externally 
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name, Session s) throws HibernateException {
		Query q = getQueryByName(name, s);
		return q.list();
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter array
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name, Serializable[] params)
		throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, params, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter array
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name, Serializable[] params, Session s)
		throws HibernateException {
		Query q = getQueryByName(name, params, s);
		return q.list();
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter Map
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name, Map params)
		throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, params, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter Map
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public java.util.List getNamedQuery(String name, Map params, Session s)
		throws HibernateException {
		Query q = getQueryByName(name, params, s);
		return q.list();
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the session given.
	 * @param name the name of a query defined externally 
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List getNamedQuery(String name, int pageNumber, int pageSize) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, pageNumber, pageSize, s);
		} finally {
			closeSession();
		}
	}
		
	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the session given.
	 * @param name the name of a query defined externally 
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List getNamedQuery(String name, int pageNumber, int pageSize, Session s) throws HibernateException {
		Query q = getQueryByName(name, s);
		return getQueryPage(q, pageNumber, pageSize);
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter array
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List getNamedQuery(String name, int pageNumber, int pageSize, Serializable[] params)
		throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, pageNumber, pageSize, params, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter array
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List getNamedQuery(String name, int pageNumber, int pageSize, Serializable[] params, Session s)
		throws HibernateException {
		Query q = getQueryByName(name, params, s);
		return getQueryPage(q, pageNumber, pageSize);
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter Map
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Map'
	* Fecha: agosto 2011
	*/
	public List getNamedQuery(String name, int pageNumber, int pageSize, Map<String,Object> params)
		throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedQuery(name, pageNumber, pageSize, params, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter Map
	 * @param s the Session
	 * @return Query result
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Map'
	* Fecha: agosto 2011
	*/
	public List getNamedQuery(String name, int pageNumber, int pageSize, Map<String,Object> params, Session s)
		throws HibernateException {
		Query q = getQueryByName(name, params, s);
		return getQueryPage(q, pageNumber, pageSize);
	}
	
	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the session given.
	 * @param name the name of a query defined externally 
	 * @param s the Session
	 * @return Query
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Query getQueryByName(String name, Session s) throws HibernateException {
		Query q = s.getNamedQuery(name);
		return q;
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter array
	 * @param s the Session
	 * @return Query
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Query getQueryByName(String name, Serializable[] params, Session s)
		throws HibernateException {
		Query q = s.getNamedQuery(name);
		if (null != params) {
			for (int i = 0; i < params.length; i++) {
				setParameterValue(q, i, params[i]);
			}
		}
		return q;
	}

	/**
	 * Obtain an instance of Query for a named query string defined in the mapping file.
	 * Use the parameters given and the Session given.
	 * @param name the name of a query defined externally 
	 * @param params the parameter Map
	 * @param s the Session
	 * @return Query
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Query getQueryByName(String name, Map params, Session s)
		throws HibernateException {
		Query q = s.getNamedQuery(name);
		if (null != params) {
			for (Iterator i=params.entrySet().iterator(); i.hasNext(); ) {
				Map.Entry entry = (Map.Entry) i.next();
				setParameterValue(q, (String) entry.getKey(), entry.getValue());
			}
		}
		return q;
	}
	
	/**
	 * Obtain an page of a query
	 * @param qry The query to execute
	 * @param pageNumber the page number
	 * @param pageSize the page size
	 * @return page sublist of a query
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List getQueryPage(Query qry, int pageNumber, int pageSize) throws HibernateException {
		int firstRow = (pageNumber*pageSize) - pageSize;
		qry.setCacheable(true);
		qry.setMaxResults(pageSize);
		qry.setFetchSize(pageSize);
		qry.setFirstResult(firstRow);
		return qry.list();
	}
	
	/**
	 * Execute a query.
	 * @param query a query expressed in Hibernate's query language
	 * @param obj a value to be bound to a "?" placeholder (JDBC IN parameter)
	 * @param type the Hibernate type of the value
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List find(String query, Object obj, Type type) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return find(query, obj, type, s);
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Perform a find but use the session given instead of creating a new one.
	 * @param query a query expressed in Hibernate's query language
	 * @param obj a value to be bound to a "?" placeholder (JDBC IN parameter)
	 * @param type the Hibernate type of the value
	 * @param s the Session to use
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List find(String query, Object obj, Type type, Session s) throws HibernateException {
		return s.find(query, obj, type);
	}

	/**
	 * Execute a query.
	 * @param query a query expressed in Hibernate's query language
	 * @param obj an array of objects to be bound to a "?" placeholder (JDBC IN parameter)
	 * @param type an array of Hibernate type of the values
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List find(String query, Object[] obj, Type[] type) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return find(query, obj, type, s);
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Perform a find but use the session given instead of creating a new one.
	 * @param query a query expressed in Hibernate's query language
	 * @param obj an array of objects to be bound to a "?" placeholder (JDBC IN parameter)
	 * @param type an array of Hibernate type of the values
	 * @param s the Session to use
	 * @return a distinct list of instances (or arrays of instances)
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public List find(String query, Object[] obj, Type[] type, Session s) throws HibernateException {
		return s.find(query, obj, type);
	}

	/**
	 * Return a Criteria object that relates to the DAO's table.
	 * A session will be created if an open one is not located.  This session must be closed!
	 * @return a Criteria object
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Criteria createCriteria () throws HibernateException {
		Session s = getSession();
		return createCriteria(s);
	}

	/**
	 * Return a Criteria object that relates to the DAO's table
	 * @param s the Session to use
	 * @return a Criteria object
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	 protected Criteria createCriteria (Session s)  {
	 	return s.createCriteria(getReferenceClass());
	 }

	/**
	 * Return the property of the class you would like to use for default ordering
	 * @return the property name
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public String getDefaultOrderProperty () {
		return null;
	}

	/**
	 * Convenience method to set paramers in the query given based on the actual object type in passed in as the value.
	 * You may need to add more functionaly to this as desired (or not use this at all).
	 * @param query the Query to set
	 * @param position the ordinal position of the current parameter within the query
	 * @param value the object to set as the parameter
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void setParameterValue(Query query, int position, Object value) 
		throws HibernateException {
		if (null == value) {
			return;
		} else if (value instanceof Boolean) {
			query.setBoolean(position, ((Boolean) value).booleanValue());
		} else if (value instanceof String) {
			query.setString(position, (String) value);
		} else if (value instanceof Integer) {
			query.setInteger(position, ((Integer) value).intValue());
		} else if (value instanceof Long) {
			query.setLong(position, ((Long) value).longValue());
		} else if (value instanceof Float) {
			query.setFloat(position, ((Float) value).floatValue());
		} else if (value instanceof Double) {
			query.setDouble(position, ((Double) value).doubleValue());
		} else if (value instanceof BigDecimal) {
			query.setBigDecimal(position, (BigDecimal) value);
		} else if (value instanceof Byte) {
			query.setByte(position, ((Byte) value).byteValue());
		} else if (value instanceof Calendar) {
			query.setCalendar(position, (Calendar) value);
		} else if (value instanceof Character) {
			query.setCharacter(position, ((Character) value).charValue());
		} else if (value instanceof Timestamp) {
			query.setTimestamp(position, (Timestamp) value);
		} else if (value instanceof Date) {
			query.setDate(position, (Date) value);
		} else if (value instanceof Short) {
			query.setShort(position, ((Short) value).shortValue());
		} else if (value != null) {
			query.setParameter(position, value);
		}
	}

	/**
	 * Convenience method to set paramers in the query given based on the actual object type in passed in as the value.
	 * You may need to add more functionaly to this as desired (or not use this at all).
	 * @param query the Query to set
	 * @param key the key name
	 * @param value the object to set as the parameter
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void setParameterValue(Query query, String key, Object value) 
		throws HibernateException {
		if (null == key || null == value) {
			return;
		} else if (value instanceof Boolean) {
			query.setBoolean(key, ((Boolean) value).booleanValue());
		} else if (value instanceof String) {
			query.setString(key, (String) value);
		} else if (value instanceof Integer) {
			query.setInteger(key, ((Integer) value).intValue());
		} else if (value instanceof Long) {
			query.setLong(key, ((Long) value).longValue());
		} else if (value instanceof Float) {
			query.setFloat(key, ((Float) value).floatValue());
		} else if (value instanceof Double) {
			query.setDouble(key, ((Double) value).doubleValue());
		} else if (value instanceof BigDecimal) {
			query.setBigDecimal(key, (BigDecimal) value);
		} else if (value instanceof Byte) {
			query.setByte(key, ((Byte) value).byteValue());
		} else if (value instanceof Calendar) {
			query.setCalendar(key, (Calendar) value);
		} else if (value instanceof Character) {
			query.setCharacter(key, ((Character) value).charValue());
		} else if (value instanceof Timestamp) {
			query.setTimestamp(key, (Timestamp) value);
		} else if (value instanceof Date) {
			query.setDate(key, (Date) value);
		} else if (value instanceof Short) {
			query.setShort(key, ((Short) value).shortValue());
		} else if (value != null) {
			query.setParameter(key, value);
		}
	}
	
	/**
	 * Return the names of all named parameters of the query.
	 * 
	 * @param queryName
	 * @param s the session to use
	 * @return the parameter names, in no particular order
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public String[] getNamedParameters(String queryName, Session s) throws HibernateException {
	    Query q = s.getNamedQuery(queryName);
	    return q.getNamedParameters();
	}
	
	/**
	 * Return the names of all named parameters of the query.
	 * 
	 * @param queryName
	 * @return the parameter names, in no particular order
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	public String[] getNamedParameters(String queryName) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return getNamedParameters(queryName, s);
		} finally {
			closeSession();
		}
	}
	

	/**
	 * Used by the base DAO classes but here for your modification
	 * Get object matching the given key and return it.
	 * @param refClass the reference
	 * @param key the key
	 * @return Object the object getted
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Class'
	* Fecha: agosto 2011
	*/
	protected Object get(Class<?> refClass, Serializable key) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return get(refClass, key, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Get object matching the given key and return it.
	 * @param refClass the reference
	 * @param key the key
	 * @param s the session to use
	 * @return Object the object getted
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Class'
	* Fecha: agosto 2011
	*/
	protected Object get(Class<?> refClass, Serializable key, Session s) throws HibernateException {
		return s.get(refClass, key);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Load object matching the given key and return it.
	 * @param refClass the reference
	 * @param key the key
	 * @return Object the object loaded
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Class'
	* Fecha: agosto 2011
	*/
	protected Object load(Class<?> refClass, Serializable key) throws HibernateException {
		Session s = null;
		try {
			s = getSession();
			return load(refClass, key, s);
		} finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Load object matching the given key and return it.
	 * @param refClass the reference
	 * @param key the key
	 * @param s the session to use
	 * @return Object the object loaded
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato contenido en los 'Class'
	* Fecha: agosto 2011
	*/
	protected Object load(Class<?> refClass, Serializable key, Session s) throws HibernateException {
		return s.load(refClass, key);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Persist the given transient instance, first assigning a generated identifier. 
	 * (Or using the current value of the identifier property if the assigned generator is used.) 
	 * @param obj the object to save
	 * @return Serializable key used
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Serializable save(Object obj) throws HibernateException {
		Transaction t = null;
		Session s = null;
		try {
			s = getSession();
			t = beginTransaction(s);
			Serializable rtn = save(obj, s);
			commitTransaction(t);
			return rtn;
		}
		catch (HibernateException e) {
			if (null != t) t.rollback();
            throw e;
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Persist the given transient instance, first assigning a generated identifier. 
	 * (Or using the current value of the identifier property if the assigned generator is used.) 
	 * @param obj the object to save
	 * @param s the session to use
	 * @return Serializable key used
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected Serializable save(Object obj, Session s) throws HibernateException {
		return s.save(obj);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Either save() or update() the given instance, depending upon the value of its
	 * identifier property.
	 * @param obj the object to save
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void saveOrUpdate(Object obj) throws HibernateException {
		Transaction t = null;
		Session s = null;
		try {
			s = getSession();
			t = beginTransaction(s);
			saveOrUpdate(obj, s);
			commitTransaction(t);
		}
		catch (HibernateException e) {
			if (null != t) t.rollback();
            throw e;
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Either save() or update() the given instance, depending upon the value of its
	 * identifier property.
	 * @param obj the object to save
	 * @param s the session to use
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void saveOrUpdate(Object obj, Session s) throws HibernateException {
		s.saveOrUpdate(obj);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent
	 * instance with the same identifier in the current session.
	 * @param obj a transient instance containing updated state
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void update(Object obj) throws HibernateException {
		Transaction t = null;
		Session s = null;
		try {
			s = getSession();
			t = beginTransaction(s);
			update(obj, s);
			commitTransaction(t);
		}
		catch (HibernateException e) {
			if (null != t) t.rollback();
            throw e;
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Update the persistent state associated with the given identifier. An exception is thrown if there is a persistent
	 * instance with the same identifier in the current session.
	 * @param obj a transient instance containing updated state
	 * @param s the Session
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void update(Object obj, Session s) throws HibernateException {
		s.update(obj);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Remove a persistent instance from the datastore. The argument may be an instance associated with the receiving
	 * Session or a transient instance with an identifier associated with existing persistent state. 
	 * @param obj the object to delete
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void delete(Object obj) throws HibernateException {
		Transaction t = null;
		Session s = null;
		try {
			s = getSession();
			t = beginTransaction(s);
			delete(obj, s);
			commitTransaction(t);
		}
		catch (HibernateException e) {
			if (null != t) t.rollback();
            throw e;
		}
		finally {
			closeSession();
		}
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Remove a persistent instance from the datastore. The argument may be an instance associated with the receiving
	 * Session or a transient instance with an identifier associated with existing persistent state. 
	 * @param obj the object to save
	 * @param s the session to use
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void delete(Object obj, Session s) throws HibernateException {
		s.delete(obj);
	}

	/**
	 * Used by the base DAO classes but here for your modification
	 * Re-read the state of the given instance from the underlying database. It is inadvisable to use this to implement
	 * long-running sessions that span many business tasks. This method is, however, useful in certain special circumstances.
	 * @param obj the object to refresh
	 * @param s the session to use
	 * @throws HibernateException
	  * @since Wed Mar 02 14:08:23 GMT-04:00 2005
	 */
	protected void refresh(Object obj, Session s) throws HibernateException {
		s.refresh(obj);
	}


	/**
	 * @see _BaseRootDAO#executeOperationInTransaction(Object, int, int, ReplicationMode, Class, Serializable, Session) 
	 */
	public Collection<Object> executeOperationInTransaction(
		Object obj2Operate,
		int Operacion,
		int BloqueCommit,
		ReplicationMode modRep,
		Class<?> tipoObjeto,
		Serializable ID)
		throws Exception {
		Session s = null;
		try {
			s = getSession();
			return executeOperationInTransaction(
				obj2Operate,
				Operacion,
				BloqueCommit,
				modRep,
				tipoObjeto,
				ID,
				s);
		} finally {
			closeSession();
		}
	}
	
	/**
	 * Let execute an operation over a collection.
	 * <p>
	 * The object to operate can be an persistable (<code>java.util.Object</code>)
	 * , an array (<code>java.util.Object[]</code>) of persistable objects
	 * or an collection (<code>java.util.Collection</code>) 
	 * of persistable objects.
	 * <p>
	 * The operation could be:
	 * <ul>
	 * <li>OPERACION_SAVE</li>
	 * <li>OPERACION_UPDATE</li>
	 * <li>OPERACION_SAVE_UPDATE</li>
	 * <li>OPERACION_SAVE_UPDATE_COPY</li>
	 * <li>OPERACION_REPLICAR</li>
	 * <li>OPERACION_CARGAR</li>
	 * <li>OPERACION_OBTENER</li>
	 * <li>OPERACION_REFRESH</li>
	 * <li>OPERACION_DELETE</li>
	 * </ul>
	 * You can define an transaction size, would let you, e.g., to commit every
	 * 10 operations. By default (if you pass BloqueCommit = null ) it takes 1000 
	 * for transaction size, if you  pass BloqueCommit = 0; the commit will be 
	 * done after the last operation. 
	 * <p>
	 * 
	 * @see net.sf.hibernate.Session#save(java.lang.Object)
	 * @see net.sf.hibernate.Session#update(java.lang.Object)
	 * @see net.sf.hibernate.Session#saveOrUpdate(java.lang.Object)
	 * @see net.sf.hibernate.Session#saveOrUpdateCopy(java.lang.Object)
	 * @see net.sf.hibernate.Session#replicate(java.lang.Object,
	 *      net.sf.hibernate.ReplicationMode)
	 * @see net.sf.hibernate.Session#load(java.lang.Class, java.io.Serializable)
	 * @see net.sf.hibernate.Session#get(java.lang.Class, java.io.Serializable)
	 * @see net.sf.hibernate.Session#refresh(java.lang.Object)
	 * @see net.sf.hibernate.Session#delete(java.lang.Object)
	 * @see ReplicationMode#EXCEPTION
	 * @see ReplicationMode#LATEST_VERSION
	 * @see ReplicationMode#OVERWRITE
	 * @see ReplicationMode#IGNORE
	 * @param obj2Operate
	 *            Object, Array or collection to store.
	 * @param Operacion
	 *            Operation to carry out
	 * @param BloqueCommit
	 *            Transaction size. By default 1000. If you indicate 0 the commit 
	 * 				will be done after de last transaction.
	 * @param modRep
	 *            Replication Mode
	 * @param tipoObjeto Object class to get or to load.
	 * @param ID
	 *            Object ID to get or to load.
	 * @return Object collection  
	 * 		   of loaded objects or object who the operation could be done. 
	 * 			If the operation was save or update, return an collection of object ID who could be saved. 
	 * @throws Exception
	 */
	/*
	* En esta función se realizaron modificaciones referentes a la migración a java 1.6 por jperez
	* Sólo se parametrizó el tipo de dato de los distintos ArrayList, Collection, Class
	* Fecha: agosto 2011
	*/
	@SuppressWarnings("unchecked")
	public Collection<Object> executeOperationInTransaction(
		Object obj2Operate,
		int Operacion,
		int BloqueCommit,
		ReplicationMode modRep,
		Class<?> tipoObjeto,
		Serializable ID,
		Session s)
		throws Exception {
		Session sess = s;
		Object salida = null;
		Collection<Object> colSalida = new ArrayList<Object>();
		Transaction tx = null;

		int iCuentaRegistros = 0;
		Collection<Object> colObj2Operate = new ArrayList<Object>();

		if (obj2Operate == null) {
			throw new IllegalArgumentException("Object or Collection invalid (null)");
		}

		if (BloqueCommit < 0)
			BloqueCommit = 1000;

		if (obj2Operate.getClass().isArray()) {
			CollectionUtils.addAll(colObj2Operate, (Object[]) obj2Operate);
		} else if (obj2Operate instanceof Collection) {
			colObj2Operate = (Collection<Object>) obj2Operate;
		} else {
			colObj2Operate.add(obj2Operate);
		}
		if (log.isDebugEnabled()) {
			log.debug(
				"Transaction asked for  " + colObj2Operate.size() + " objects");
		}

		try {
			tx = sess.beginTransaction();

			Iterator<Object> itObject2Operate = colObj2Operate.iterator();

			while (itObject2Operate.hasNext()) {
				Object obj2Operar = itObject2Operate.next();
				switch (Operacion) {
					case OPERACION_SAVE :
						salida = sess.save(obj2Operar);
						break;

					case OPERACION_UPDATE :
						sess.update(obj2Operar);
						salida = sess.getIdentifier(obj2Operar);
						break;

					case OPERACION_SAVE_UPDATE :
						sess.saveOrUpdate(obj2Operar);
						salida = sess.getIdentifier(obj2Operar);
						break;

					case OPERACION_SAVE_UPDATE_COPY :
						salida = sess.saveOrUpdateCopy(obj2Operar);
						break;

					case OPERACION_CARGAR :
						if (tipoObjeto == null) {
							throw new IllegalArgumentException("Invalid class (null)");
						}
						if (ID == null) {
							throw new IllegalArgumentException("Invalid ID (null)");
						}
						salida = sess.load(tipoObjeto, ID);
						break;

					case OPERACION_OBTENER :
						if (tipoObjeto == null) {
							throw new IllegalArgumentException("Invalid class (null)");
						}
						if (ID == null) {
							throw new IllegalArgumentException("Invalid ID (null)");
						}
						salida = sess.get(tipoObjeto, ID);
						break;

					case OPERACION_DELETE :
						sess.delete(obj2Operar);
						salida = obj2Operar;
						break;

					case OPERACION_REFRESH :
						sess.refresh(obj2Operar);
						salida = obj2Operar;
						break;

					case OPERACION_REPLICAR :
						if (modRep == null
							|| !(modRep instanceof ReplicationMode)) {
							throw new IllegalArgumentException("Replication Mode invalid");
						}

						sess.replicate(obj2Operar, modRep);
						salida = obj2Operar;
						break;

					default :
						IllegalArgumentException illArgEx =
							new IllegalArgumentException("Invalid Operation");
						throw illArgEx;
				}
				iCuentaRegistros++;
				if (BloqueCommit != 0
					&& (iCuentaRegistros % BloqueCommit == 0)) {
					tx.commit();
				}

				colSalida.add(salida);
				salida = null;

			}

			tx.commit();
		} catch (Exception e) {
			if (tx != null)
				tx.rollback();
			log.error(
				"The operation couldn't be done: " + e.getLocalizedMessage());
			throw e;
		}
		if (log.isDebugEnabled()) {
			log.debug(
				"Transaction done, returning " + colSalida.size() + " objects");
		}

		return colSalida;

	}




}